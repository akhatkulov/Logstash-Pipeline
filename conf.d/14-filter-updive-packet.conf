# =============================================================================
# 14-filter-updive-packet.conf - Packetbeat/updive-packet qayta ishlash
# Tarmoq telemetriyasi: oqimlar, DNS, HTTP, TLS va h.k.
# =============================================================================

filter {
  if [@metadata][updive_type] == "packet" {

    # Asosiy voqea metadatasini o'rnatish
    mutate {
      add_field => {
        "[event][module]" => "updive-packet"
        "[event][kind]" => "event"
        "[event][category]" => "network"
      }
    }

    # -------------------------------------------------------------------------
    # Protokol turi asosida dataset tayinlash
    # -------------------------------------------------------------------------
    if [type] {
      mutate {
        add_field => { "[event][dataset]" => "updive-packet.%{[type]}" }
      }
    } else if [network][protocol] {
      mutate {
        add_field => { "[event][dataset]" => "updive-packet.%{[network][protocol]}" }
      }
    } else {
      mutate {
        add_field => { "[event][dataset]" => "updive-packet.flow" }
      }
    }

    # -------------------------------------------------------------------------
    # Paket yo'nalishi/holati asosida voqea turi
    # -------------------------------------------------------------------------
    if [status] == "OK" or [event][outcome] == "success" {
      mutate {
        add_field => {
          "[event][type]" => "connection"
          "[event][outcome]" => "success"
        }
      }
    } else if [status] == "Error" or [event][outcome] == "failure" {
      mutate {
        add_field => {
          "[event][type]" => "connection"
          "[event][outcome]" => "failure"
        }
      }
    } else {
      mutate {
        add_field => { "[event][type]" => "connection" }
      }
    }

    # -------------------------------------------------------------------------
    # DNS protokoli qayta ishlash
    # -------------------------------------------------------------------------
    if [type] == "dns" or [network][protocol] == "dns" {
      mutate {
        replace => { "[event][category]" => "network" }
        add_field => { "[event][action]" => "dns_query" }
      }

      # DNS maydonlarini ECS ga normalizatsiya qilish
      if [dns][question][name] and ![dns][question][registered_domain] {
        ruby {
          code => '
            name = event.get("[dns][question][name]")
            if name
              parts = name.to_s.split(".")
              if parts.length >= 2
                event.set("[dns][question][registered_domain]", parts[-2..-1].join("."))
                event.set("[dns][question][top_level_domain]", parts[-1])
              end
            end
          '
        }
      }

      # DNS natijasi
      if [dns][response_code] == "NOERROR" {
        mutate { replace => { "[event][outcome]" => "success" } }
      } else if [dns][response_code] =~ /(NXDOMAIN|SERVFAIL|REFUSED)/ {
        mutate { replace => { "[event][outcome]" => "failure" } }
      }
    }

    # -------------------------------------------------------------------------
    # HTTP protokoli qayta ishlash
    # -------------------------------------------------------------------------
    if [type] == "http" or [network][protocol] == "http" {
      mutate {
        add_field => { "[event][action]" => "http_request" }
      }

      # Status kod butun son ekanligini ta'minlash
      if [http][response][status_code] {
        mutate {
          convert => { "[http][response][status_code]" => "integer" }
        }

        # Status kodga asoslangan natijani o'rnatish
        if [http][response][status_code] < 400 {
          mutate { replace => { "[event][outcome]" => "success" } }
        } else {
          mutate { replace => { "[event][outcome]" => "failure" } }
        }
      }

      # Mavjud bo'lsa foydalanuvchi agentini tahlil qilish
      if [user_agent][original] {
        useragent {
          source => "[user_agent][original]"
          target => "[user_agent]"
          ecs_compatibility => v8
        }
      }
    }

    # -------------------------------------------------------------------------
    # TLS protokoli qayta ishlash
    # -------------------------------------------------------------------------
    if [type] == "tls" or [tls][established] {
      mutate {
        add_field => { "[event][action]" => "tls_handshake" }
      }

      # TLS versiya normalizatsiyasi
      if [tls][version] {
        mutate {
          add_field => { "[tls][version_protocol]" => "tls" }
        }
      }

      # Sertifikat ma'lumotlari
      if [tls][server][x509][not_after] {
        ruby {
          code => '
            not_after = event.get("[tls][server][x509][not_after]")
            if not_after
              begin
                expiry = Time.parse(not_after.to_s)
                days_until = ((expiry - Time.now) / 86400).to_i
                event.set("[tls][server][x509][days_until_expiry]", days_until)
              rescue
              end
            end
          '
        }
      }
    }

    # -------------------------------------------------------------------------
    # Oqim/Ulanish qayta ishlash
    # -------------------------------------------------------------------------
    if [type] == "flow" {
      mutate {
        replace => { "[event][type]" => "connection" }
        add_field => { "[event][action]" => "network_flow" }
      }
    }

    # -------------------------------------------------------------------------
    # Community ID (tarmoq oqimi korrelyatsiyasi)
    # -------------------------------------------------------------------------
    # Packetbeat allaqachon community_id yaratishi kerak, lekin to'g'ri joyda ekanligini ta'minlash
    if [network][community_id] and ![community_id] {
      mutate {
        add_field => { "[community_id]" => "%{[network][community_id]}" }
      }
    }

    # -------------------------------------------------------------------------
    # To'g'ri IP/Port maydon turlarini ta'minlash
    # -------------------------------------------------------------------------
    mutate {
      convert => {
        "[source][port]" => "integer"
        "[destination][port]" => "integer"
        "[source][bytes]" => "integer"
        "[destination][bytes]" => "integer"
        "[network][bytes]" => "integer"
        "[network][packets]" => "integer"
      }
    }

    # -------------------------------------------------------------------------
    # GeoIP boyitish
    # -------------------------------------------------------------------------
    if [source][ip] {
      # GeoIP uchun shaxsiy IPlarni otkazib yuborish
      if [source][ip] !~ /^(10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.|127\.)/ {
        geoip {
          source => "[source][ip]"
          target => "[source][geo]"
          ecs_compatibility => v8
          tag_on_failure => ["_geoip_source_failure"]
        }
        geoip {
          source => "[source][ip]"
          target => "[source][as]"
          default_database_type => "ASN"
          ecs_compatibility => v8
          tag_on_failure => ["_geoip_asn_source_failure"]
        }
      }
    }

    if [destination][ip] {
      if [destination][ip] !~ /^(10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.|127\.)/ {
        geoip {
          source => "[destination][ip]"
          target => "[destination][geo]"
          ecs_compatibility => v8
          tag_on_failure => ["_geoip_dest_failure"]
        }
        geoip {
          source => "[destination][ip]"
          target => "[destination][as]"
          default_database_type => "ASN"
          ecs_compatibility => v8
          tag_on_failure => ["_geoip_asn_dest_failure"]
        }
      }
    }

    # -------------------------------------------------------------------------
    # Bog'liq maydonlar
    # -------------------------------------------------------------------------
    ruby {
      code => '
        related_ips = []
        related_hosts = []

        # IPlar
        src_ip = event.get("[source][ip]")
        related_ips << src_ip if src_ip

        dst_ip = event.get("[destination][ip]")
        related_ips << dst_ip if dst_ip

        # Hostlar/Domenlar
        dst_domain = event.get("[destination][domain]")
        related_hosts << dst_domain if dst_domain

        dns_name = event.get("[dns][question][name]")
        related_hosts << dns_name if dns_name

        url_domain = event.get("[url][domain]")
        related_hosts << url_domain if url_domain

        tls_server = event.get("[tls][server][x509][subject][common_name]")
        related_hosts << tls_server if tls_server

        event.set("[related][ip]", related_ips.uniq) unless related_ips.empty?
        event.set("[related][hosts]", related_hosts.uniq) unless related_hosts.empty?
      '
    }

    # -------------------------------------------------------------------------
    # Shovqin nazorati
    # -------------------------------------------------------------------------
    # Xato bo'lmasa faqat ichki trafikni tashlab yuborish
    if [source][ip] =~ /^(10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.)/ {
      if [destination][ip] =~ /^(10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.)/ {
        # Ichkidan ichkiga - qiziqarli bo'lmasa tashlab yuborish
        if [event][outcome] != "failure" {
          # Ichki trafikning faqat namunasini saqlash
          ruby {
            code => '
              event.cancel if rand(10) != 0
            '
          }
        }
      }
    }

    # Keng tarqalgan broadcast/multicastni tashlab yuborish
    if [destination][ip] =~ /^(224\.|239\.|255\.255\.255\.255)/ {
      drop { }
    }

    # LLMNR/mDNS shovqinini tashlab yuborish
    if [destination][port] == 5353 or [destination][port] == 5355 {
      drop { }
    }

    # -------------------------------------------------------------------------
    # Tozalash
    # -------------------------------------------------------------------------
    mutate {
      remove_field => [
        "[type]",
        "[status]",
        "[method]",
        "[path]",
        "[query]",
        "[request]",
        "[response]"
      ]
    }
  }
}
