# =============================================================================
# 16-filter-sysmon.conf - Sysmon Events (Microsoft-Windows-Sysmon)
# Bu Windows uchun ENG MUHIM SIEM detection manbasi!
# Hash, CommandLine, Network, Registry, va boshqa events
# =============================================================================

filter {
  if [@metadata][updive_type] == "win" and [winlog][provider_name] == "Microsoft-Windows-Sysmon" {
    
    # Asosiy metadata
    mutate {
      add_field => {
        "[event][module]" => "sysmon"
        "[event][kind]" => "event"
      }
    }
    
    # =========================================================================
    # EVENT ID 1: Process Creation (Eng muhim detection event!)
    # =========================================================================
    if [winlog][event_id] == 1 {
      ruby {
        code => '
          event.set("[event][category]", ["process"])
          event.set("[event][type]", ["start"])
        '
      }
      mutate {
        add_field => {
          "[event][action]" => "process_created"
          "[event][outcome]" => "success"
          "[event][dataset]" => "sysmon.process"
        }
      }
      
      # Process fieldlarini to'ldirish
      if [winlog][event_data][Image] {
        mutate {
          copy => { "[winlog][event_data][Image]" => "[process][executable]" }
        }
        ruby {
          code => '
            exe = event.get("[process][executable]")
            if exe
              event.set("[process][name]", File.basename(exe.to_s))
              # Working directory
              event.set("[process][working_directory]", File.dirname(exe.to_s))
            end
          '
        }
      }
      
      if [winlog][event_data][ProcessId] {
        mutate {
          copy => { "[winlog][event_data][ProcessId]" => "[process][pid]" }
          convert => { "[process][pid]" => "integer" }
        }
      }
      
      if [winlog][event_data][ProcessGuid] {
        mutate {
          copy => { "[winlog][event_data][ProcessGuid]" => "[process][entity_id]" }
        }
      }
      
      if [winlog][event_data][CommandLine] {
        mutate {
          copy => { "[winlog][event_data][CommandLine]" => "[process][command_line]" }
        }
      }
      
      if [winlog][event_data][CurrentDirectory] {
        mutate {
          copy => { "[winlog][event_data][CurrentDirectory]" => "[process][working_directory]" }
        }
      }
      
      # HASH - Juda muhim IOC matching uchun!
      if [winlog][event_data][Hashes] {
        ruby {
          code => '
            hashes_str = event.get("[winlog][event_data][Hashes]")
            if hashes_str
              hashes_str.split(",").each do |h|
                algo, value = h.split("=")
                if algo && value
                  algo_lower = algo.downcase
                  event.set("[process][hash][#{algo_lower}]", value)
                end
              end
            end
          '
        }
      }
      
      # Parent Process - Critical for detection!
      if [winlog][event_data][ParentImage] {
        mutate {
          copy => { "[winlog][event_data][ParentImage]" => "[process][parent][executable]" }
        }
        ruby {
          code => '
            exe = event.get("[process][parent][executable]")
            event.set("[process][parent][name]", File.basename(exe.to_s)) if exe
          '
        }
      }
      
      if [winlog][event_data][ParentProcessId] {
        mutate {
          copy => { "[winlog][event_data][ParentProcessId]" => "[process][parent][pid]" }
          convert => { "[process][parent][pid]" => "integer" }
        }
      }
      
      if [winlog][event_data][ParentProcessGuid] {
        mutate {
          copy => { "[winlog][event_data][ParentProcessGuid]" => "[process][parent][entity_id]" }
        }
      }
      
      if [winlog][event_data][ParentCommandLine] {
        mutate {
          copy => { "[winlog][event_data][ParentCommandLine]" => "[process][parent][command_line]" }
        }
      }
      
      # User
      if [winlog][event_data][User] {
        ruby {
          code => '
            user_full = event.get("[winlog][event_data][User]")
            if user_full
              parts = user_full.split("\\\\")
              if parts.length == 2
                event.set("[user][domain]", parts[0])
                event.set("[user][name]", parts[1])
              else
                event.set("[user][name]", user_full)
              end
            end
          '
        }
      }
      
      # Integrity Level
      if [winlog][event_data][IntegrityLevel] {
        mutate {
          copy => { "[winlog][event_data][IntegrityLevel]" => "[process][integrity_level]" }
        }
      }
    }
    
    # =========================================================================
    # EVENT ID 3: Network Connection
    # =========================================================================
    else if [winlog][event_id] == 3 {
      ruby {
        code => '
          event.set("[event][category]", ["network"])
          event.set("[event][type]", ["connection", "start"])
        '
      }
      mutate {
        add_field => {
          "[event][action]" => "network_connection"
          "[event][outcome]" => "success"
          "[event][dataset]" => "sysmon.network"
        }
      }
      
      # Source
      if [winlog][event_data][SourceIp] {
        mutate {
          copy => { "[winlog][event_data][SourceIp]" => "[source][ip]" }
        }
      }
      if [winlog][event_data][SourcePort] {
        mutate {
          copy => { "[winlog][event_data][SourcePort]" => "[source][port]" }
          convert => { "[source][port]" => "integer" }
        }
      }
      
      # Destination
      if [winlog][event_data][DestinationIp] {
        mutate {
          copy => { "[winlog][event_data][DestinationIp]" => "[destination][ip]" }
        }
      }
      if [winlog][event_data][DestinationPort] {
        mutate {
          copy => { "[winlog][event_data][DestinationPort]" => "[destination][port]" }
          convert => { "[destination][port]" => "integer" }
        }
      }
      if [winlog][event_data][DestinationHostname] {
        mutate {
          copy => { "[winlog][event_data][DestinationHostname]" => "[destination][domain]" }
        }
      }
      
      # Protocol
      if [winlog][event_data][Protocol] {
        translate {
          source => "[winlog][event_data][Protocol]"
          target => "[network][transport]"
          dictionary => {
            "tcp" => "tcp"
            "udp" => "udp"
            "6" => "tcp"
            "17" => "udp"
          }
          fallback => "unknown"
        }
      }
      
      # Process that made connection
      if [winlog][event_data][Image] {
        mutate {
          copy => { "[winlog][event_data][Image]" => "[process][executable]" }
        }
        ruby {
          code => '
            exe = event.get("[process][executable]")
            event.set("[process][name]", File.basename(exe.to_s)) if exe
          '
        }
      }
      
      if [winlog][event_data][ProcessId] {
        mutate {
          copy => { "[winlog][event_data][ProcessId]" => "[process][pid]" }
          convert => { "[process][pid]" => "integer" }
        }
      }
      
      # Network direction
      if [winlog][event_data][Initiated] {
        if [winlog][event_data][Initiated] == "true" {
          mutate { add_field => { "[network][direction]" => "egress" } }
        } else {
          mutate { add_field => { "[network][direction]" => "ingress" } }
        }
      }
      
      # GeoIP for destination
      if [destination][ip] {
        if [destination][ip] !~ /^(10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.|127\.)/ {
          geoip {
            source => "[destination][ip]"
            target => "[destination][geo]"
            ecs_compatibility => v8
            tag_on_failure => ["_geoip_dest_failure"]
          }
        }
      }
    }
    
    # =========================================================================
    # EVENT ID 7: Image Loaded (DLL)
    # =========================================================================
    else if [winlog][event_id] == 7 {
      ruby {
        code => '
          event.set("[event][category]", ["process"])
          event.set("[event][type]", ["info"])
        '
      }
      mutate {
        add_field => {
          "[event][action]" => "image_loaded"
          "[event][dataset]" => "sysmon.imageload"
        }
      }
      
      if [winlog][event_data][ImageLoaded] {
        mutate {
          copy => { "[winlog][event_data][ImageLoaded]" => "[dll][path]" }
        }
        ruby {
          code => '
            path = event.get("[dll][path]")
            event.set("[dll][name]", File.basename(path.to_s)) if path
          '
        }
      }
      
      # DLL Hash
      if [winlog][event_data][Hashes] {
        ruby {
          code => '
            hashes_str = event.get("[winlog][event_data][Hashes]")
            if hashes_str
              hashes_str.split(",").each do |h|
                algo, value = h.split("=")
                if algo && value
                  algo_lower = algo.downcase
                  event.set("[dll][hash][#{algo_lower}]", value)
                end
              end
            end
          '
        }
      }
      
      # Signed status
      if [winlog][event_data][Signed] {
        mutate {
          copy => { "[winlog][event_data][Signed]" => "[dll][code_signature][exists]" }
        }
      }
      
      if [winlog][event_data][Signature] {
        mutate {
          copy => { "[winlog][event_data][Signature]" => "[dll][code_signature][subject_name]" }
        }
      }
    }
    
    # =========================================================================
    # EVENT ID 10: Process Access (Injection detection)
    # =========================================================================
    else if [winlog][event_id] == 10 {
      ruby {
        code => '
          event.set("[event][category]", ["process"])
          event.set("[event][type]", ["access"])
        '
      }
      mutate {
        add_field => {
          "[event][action]" => "process_access"
          "[event][dataset]" => "sysmon.process_access"
        }
      }
      
      # Source Process
      if [winlog][event_data][SourceImage] {
        mutate {
          copy => { "[winlog][event_data][SourceImage]" => "[process][executable]" }
        }
      }
      if [winlog][event_data][SourceProcessId] {
        mutate {
          copy => { "[winlog][event_data][SourceProcessId]" => "[process][pid]" }
          convert => { "[process][pid]" => "integer" }
        }
      }
      
      # Target Process
      if [winlog][event_data][TargetImage] {
        mutate {
          copy => { "[winlog][event_data][TargetImage]" => "[process][target][executable]" }
        }
      }
      if [winlog][event_data][TargetProcessId] {
        mutate {
          copy => { "[winlog][event_data][TargetProcessId]" => "[process][target][pid]" }
          convert => { "[process][target][pid]" => "integer" }
        }
      }
      
      # Call Trace - Memory injection signature
      if [winlog][event_data][CallTrace] {
        mutate {
          copy => { "[winlog][event_data][CallTrace]" => "[sysmon][process_access][call_trace]" }
        }
      }
      
      # Granted Access
      if [winlog][event_data][GrantedAccess] {
        mutate {
          copy => { "[winlog][event_data][GrantedAccess]" => "[sysmon][process_access][granted_access]" }
        }
      }
    }
    
    # =========================================================================
    # EVENT ID 11: File Create
    # =========================================================================
    else if [winlog][event_id] == 11 {
      ruby {
        code => '
          event.set("[event][category]", ["file"])
          event.set("[event][type]", ["creation"])
        '
      }
      mutate {
        add_field => {
          "[event][action]" => "file_created"
          "[event][outcome]" => "success"
          "[event][dataset]" => "sysmon.file"
        }
      }
      
      if [winlog][event_data][TargetFilename] {
        mutate {
          copy => { "[winlog][event_data][TargetFilename]" => "[file][path]" }
        }
        ruby {
          code => '
            path = event.get("[file][path]")
            if path
              event.set("[file][name]", File.basename(path.to_s))
              event.set("[file][directory]", File.dirname(path.to_s))
              ext = File.extname(path.to_s).gsub(".", "")
              event.set("[file][extension]", ext) unless ext.empty?
            end
          '
        }
      }
      
      if [winlog][event_data][Image] {
        mutate {
          copy => { "[winlog][event_data][Image]" => "[process][executable]" }
        }
      }
    }
    
    # =========================================================================
    # EVENT ID 12, 13, 14: Registry Events
    # =========================================================================
    else if [winlog][event_id] in [12, 13, 14] {
      ruby {
        code => '
          event.set("[event][category]", ["registry"])
          event_id = event.get("[winlog][event_id]")
          if event_id == 12
            event.set("[event][type]", ["creation", "deletion"])
          elsif event_id == 13
            event.set("[event][type]", ["change"])
          elsif event_id == 14
            event.set("[event][type]", ["change"])
          end
        '
      }
      mutate {
        add_field => {
          "[event][action]" => "registry_modification"
          "[event][dataset]" => "sysmon.registry"
        }
      }
      
      if [winlog][event_data][TargetObject] {
        mutate {
          copy => { "[winlog][event_data][TargetObject]" => "[registry][path]" }
        }
        ruby {
          code => '
            path = event.get("[registry][path]")
            if path
              parts = path.to_s.split("\\\\")
              event.set("[registry][hive]", parts[0]) if parts[0]
              event.set("[registry][key]", parts[1..-2].join("\\\\")) if parts.length > 2
              event.set("[registry][value]", parts[-1]) if parts.length > 1
            end
          '
        }
      }
      
      if [winlog][event_data][Details] {
        mutate {
          copy => { "[winlog][event_data][Details]" => "[registry][data][strings]" }
        }
      }
    }
    
    # =========================================================================
    # EVENT ID 22: DNS Query
    # =========================================================================
    else if [winlog][event_id] == 22 {
      ruby {
        code => '
          event.set("[event][category]", ["network"])
          event.set("[event][type]", ["protocol"])
        '
      }
      mutate {
        add_field => {
          "[event][action]" => "dns_query"
          "[event][dataset]" => "sysmon.dns"
          "[network][protocol]" => "dns"
        }
      }
      
      if [winlog][event_data][QueryName] {
        mutate {
          copy => { "[winlog][event_data][QueryName]" => "[dns][question][name]" }
        }
        ruby {
          code => '
            name = event.get("[dns][question][name]")
            if name
              parts = name.to_s.split(".")
              if parts.length >= 2
                event.set("[dns][question][registered_domain]", parts[-2..-1].join("."))
                event.set("[dns][question][top_level_domain]", parts[-1])
              end
            end
          '
        }
      }
      
      if [winlog][event_data][QueryResults] {
        mutate {
          copy => { "[winlog][event_data][QueryResults]" => "[dns][answers][data]" }
        }
      }
      
      if [winlog][event_data][Image] {
        mutate {
          copy => { "[winlog][event_data][Image]" => "[process][executable]" }
        }
      }
    }
    
    # =========================================================================
    # Related fields to'ldirish
    # =========================================================================
    ruby {
      code => '
        related_ips = []
        related_hashes = []
        related_hosts = []
        related_users = []
        
        # IPs
        ["[source][ip]", "[destination][ip]"].each do |path|
          val = event.get(path)
          related_ips << val if val
        end
        
        # Hashes - process and dll
        ["md5", "sha1", "sha256"].each do |algo|
          ["[process][hash]", "[dll][hash]", "[file][hash]"].each do |prefix|
            val = event.get("#{prefix}[#{algo}]")
            related_hashes << val if val
          end
        end
        
        # Hosts
        dst_domain = event.get("[destination][domain]")
        related_hosts << dst_domain if dst_domain
        
        dns_name = event.get("[dns][question][name]")
        related_hosts << dns_name if dns_name
        
        # Users
        user_name = event.get("[user][name]")
        related_users << user_name if user_name
        
        event.set("[related][ip]", related_ips.uniq) unless related_ips.empty?
        event.set("[related][hash]", related_hashes.uniq) unless related_hashes.empty?
        event.set("[related][host]", related_hosts.uniq) unless related_hosts.empty?
        event.set("[related][user]", related_users.uniq) unless related_users.empty?
      '
    }
  }
}
