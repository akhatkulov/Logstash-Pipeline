# =============================================================================
# 98-siem-enrichment.conf - SIEM/ESQL Detection Engine uchun ECS Boyitish
# Barcha agent turlariga tegishli umumiy SIEM zarur fieldlari
# =============================================================================

filter {
  # =========================================================================
  # 1. HOST.OS.* FIELDLARINI TO'LDIRISH (Juda muhim SIEM uchun)
  # =========================================================================
  
  # Windows hostlar uchun
  if [@metadata][updive_type] == "win" {
    if ![host][os][type] {
      mutate {
        add_field => {
          "[host][os][type]" => "windows"
          "[host][os][family]" => "windows"
        }
      }
    }
    # Windows versiyasini Winlogbeat'dan olish
    if [winlog][computer_name] and ![host][hostname] {
      mutate {
        copy => { "[winlog][computer_name]" => "[host][hostname]" }
      }
    }
  }
  
  # Linux/Unix hostlar uchun (Auditbeat, Filebeat, Packetbeat)
  if [@metadata][updive_type] in ["audit", "file", "packet", "metric", "heart"] {
    if [host][os][family] {
      # Allaqachon mavjud bo'lsa, o'tkazib yubor
    } else if [host][os][kernel] =~ /[Ll]inux/ or [host][os][type] == "linux" {
      mutate {
        add_field => {
          "[host][os][type]" => "linux"
          "[host][os][family]" => "linux"
        }
      }
    } else if [host][os][kernel] =~ /[Dd]arwin/ or [host][os][type] == "macos" {
      mutate {
        add_field => {
          "[host][os][type]" => "macos"
          "[host][os][family]" => "darwin"
        }
      }
    }
  }
  
  # =========================================================================
  # 2. USER.ID FIELDINI TO'LDIRISH (Authentication detection uchun muhim)
  # =========================================================================
  
  # Windows - SubjectUserSid yoki TargetUserSid dan
  if [@metadata][updive_type] == "win" {
    if [winlog][event_data][TargetUserSid] and ![user][id] {
      mutate {
        copy => { "[winlog][event_data][TargetUserSid]" => "[user][target][id]" }
      }
    }
    if [winlog][event_data][SubjectUserSid] and ![user][id] {
      mutate {
        copy => { "[winlog][event_data][SubjectUserSid]" => "[user][id]" }
      }
    }
    # LogonId ni session id sifatida
    if [winlog][event_data][TargetLogonId] {
      mutate {
        copy => { "[winlog][event_data][TargetLogonId]" => "[winlog][logon][id]" }
      }
    }
  }
  
  # Linux - uid dan
  if [@metadata][updive_type] in ["audit", "file"] {
    if [user][audit][id] and ![user][id] {
      mutate {
        copy => { "[user][audit][id]" => "[user][id]" }
      }
    }
    if [auditd][summary][actor][primary] and ![user][name] {
      mutate {
        copy => { "[auditd][summary][actor][primary]" => "[user][name]" }
      }
    }
  }
  
  # =========================================================================
  # 3. PROCESS FIELDLARINI TO'LDIRISH (Process hunting uchun juda muhim)
  # =========================================================================
  
  # Windows process events - 4688
  if [@metadata][updive_type] == "win" and [winlog][event_id] == 4688 {
    # Process entity_id (benzersiz identifikator)
    if [winlog][event_data][NewProcessId] and [winlog][event_data][ProcessId] {
      ruby {
        code => '
          new_pid = event.get("[winlog][event_data][NewProcessId]")
          parent_pid = event.get("[winlog][event_data][ProcessId]")
          timestamp = event.get("@timestamp").to_s
          host = event.get("[host][name]") || "unknown"
          
          # Entity ID yaratish
          if new_pid
            entity_id = Digest::SHA256.hexdigest("#{host}-#{new_pid}-#{timestamp}")[0..15]
            event.set("[process][entity_id]", entity_id)
          end
        '
      }
    }
    
    # Parent Process maydonlarini to'ldirish
    if [winlog][event_data][ProcessId] and ![process][parent][pid] {
      mutate {
        copy => { "[winlog][event_data][ProcessId]" => "[process][parent][pid]" }
      }
      ruby {
        code => '
          ppid = event.get("[process][parent][pid]")
          if ppid
            event.set("[process][parent][pid]", ppid.to_s.to_i(16))
          end
        '
      }
    }
    
    if [winlog][event_data][ParentProcessName] and ![process][parent][executable] {
      mutate {
        copy => { "[winlog][event_data][ParentProcessName]" => "[process][parent][executable]" }
      }
      ruby {
        code => '
          exe = event.get("[process][parent][executable]")
          if exe
            event.set("[process][parent][name]", File.basename(exe.to_s))
          end
        '
      }
    }
    
    # SubjectUserName ni actor sifatida
    if [winlog][event_data][SubjectUserName] and ![process][user][name] {
      mutate {
        copy => { "[winlog][event_data][SubjectUserName]" => "[user][name]" }
      }
    }
    
    # Token Elevation
    if [winlog][event_data][TokenElevationType] {
      mutate {
        copy => { "[winlog][event_data][TokenElevationType]" => "[process][token][elevation_type]" }
      }
    }
  }
  
  # =========================================================================
  # 4. NETWORK.DIRECTION FIELDINI TO'LDIRISH (Network detection uchun muhim)
  # =========================================================================
  
  if [@metadata][updive_type] == "packet" {
    if ![network][direction] {
      ruby {
        code => '
          src_ip = event.get("[source][ip]")
          dst_ip = event.get("[destination][ip]")
          
          # Private IP ranges
          private_regex = /^(10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.|127\.)/
          
          if src_ip && dst_ip
            src_private = src_ip.match?(private_regex)
            dst_private = dst_ip.match?(private_regex)
            
            if src_private && !dst_private
              event.set("[network][direction]", "egress")  # Outbound
            elsif !src_private && dst_private
              event.set("[network][direction]", "ingress") # Inbound
            elsif src_private && dst_private
              event.set("[network][direction]", "internal")
            else
              event.set("[network][direction]", "external")
            end
          end
        '
      }
    }
  }
  
  # =========================================================================
  # 5. FILE.HASH FIELDLARINI NORMALIZE QILISH (IOC matching uchun muhim)
  # =========================================================================
  
  # Auditbeat file integrity monitoring
  if [@metadata][updive_type] == "audit" and [file][hash] {
    # Hash'larni related.hash ga qo'shish
    ruby {
      code => '
        hashes = []
        ["md5", "sha1", "sha256", "sha512"].each do |algo|
          hash = event.get("[file][hash][#{algo}]")
          hashes << hash if hash
        end
        event.set("[related][hash]", hashes.uniq) unless hashes.empty?
      '
    }
  }
  
  # =========================================================================
  # 6. THREAT INTEL ENRICHMENT PREPARATION
  # =========================================================================
  
  # threat.indicator bilan ishlash uchun marker
  ruby {
    code => '
      # IP addresses bo'lsa, threat intel matching uchun tayyor
      related_ips = event.get("[related][ip]")
      if related_ips && related_ips.is_a?(Array) && !related_ips.empty?
        event.set("[@metadata][has_ips_for_ti]", true)
      end
      
      # Hash bo'lsa, threat intel matching uchun tayyor
      related_hashes = event.get("[related][hash]")
      if related_hashes && related_hashes.is_a?(Array) && !related_hashes.empty?
        event.set("[@metadata][has_hashes_for_ti]", true)
      end
    '
  }
  
  # =========================================================================
  # 7. EVENT.RISK_SCORE VA SEVERITY (Detection prioritization)
  # =========================================================================
  
  ruby {
    code => '
      risk_score = 0
      
      # Authentication failures - higher risk
      category = event.get("[event][category]")
      outcome = event.get("[event][outcome]")
      action = event.get("[event][action]")
      
      if category.is_a?(Array)
        if category.include?("authentication")
          if outcome == "failure"
            risk_score += 25
          end
        end
        
        if category.include?("iam")
          # Account changes are important
          risk_score += 15
        end
        
        if category.include?("process")
          # Process creation with command line
          cmdline = event.get("[process][command_line]")
          if cmdline
            # Suspicious patterns
            if cmdline.match?(/powershell.*-enc|-e\s|cmd.*\/c|certutil.*-decode|mshta|regsvr32|rundll32/i)
              risk_score += 50
            end
          end
        end
      end
      
      # External source IP
      src_geo = event.get("[source][geo][country_iso_code]")
      if src_geo && !["UZ", "RU", "KZ"].include?(src_geo)
        risk_score += 10
      end
      
      event.set("[event][risk_score]", risk_score) if risk_score > 0
    '
  }
  
  # =========================================================================
  # 8. AGENT VA OBSERVER FIELDLARINI TO'LDIRISH
  # =========================================================================
  
  # Observer (Logstash server) ma'lumotlari
  if ![observer][type] {
    mutate {
      add_field => {
        "[observer][type]" => "logstash"
        "[observer][vendor]" => "Elastic"
        "[observer][product]" => "Logstash"
      }
    }
  }
  
  # =========================================================================
  # 9. LABELS VA TAGS (Custom detection markers)
  # =========================================================================
  
  # High-value targets marking
  if [user][name] {
    ruby {
      code => '
        username = event.get("[user][name]")
        if username
          # Admin accounts
          if username.downcase.match?(/admin|root|administrator|sysadmin|dba/)
            labels = event.get("[labels]") || {}
            labels["high_value_target"] = "true"
            event.set("[labels]", labels)
          end
        end
      '
    }
  }
  
  # =========================================================================
  # 10. RULE.* FIELDLARINI TAYYORLASH (Detection correlation)
  # =========================================================================
  
  # Bu fieldlar detection rule trigger bo'lganda to'ldiriladi
  # Lekin base structure tayyor bo'lishi kerak
  if ![rule] {
    mutate {
      add_field => {
        "[rule][ruleset]" => "updive-siem"
      }
    }
  }
}
